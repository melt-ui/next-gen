{
  "utils": {
    "constructorProps": [],
    "methods": [],
    "properties": []
  },
  "Tree": {
    "constructorProps": [
      {
        "name": "multiple",
        "type": "MaybeGetter<Multiple | undefined>",
        "description": "If `true`, the user can select multiple items.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "selected",
        "type": "MaybeMultiple<string, Multiple> | undefined",
        "description": "The currently selected item(s).\r\nIf `multiple` is `true`, this should be an `Iterable`.\r\nOtherwise, it'll be a `string`.",
        "defaultValue": "undefined",
        "optional": true
      },
      {
        "name": "onSelectedChange",
        "type": "| ((value: Multiple extends true ? Set<string> : string | undefined) => void)\n  | undefined",
        "description": "Callback fired when selection changes",
        "optional": true
      },
      {
        "name": "expanded",
        "type": "IterableProp<string>",
        "description": "The currently expanded items",
        "defaultValue": "undefined",
        "optional": true
      },
      {
        "name": "onExpandedChange",
        "type": "((value: Set<string>) => void) | undefined",
        "description": "Callback fired when expanded state changes",
        "optional": true
      },
      {
        "name": "expandOnClick",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If `true`, groups (items with children) expand on click.",
        "defaultValue": "true",
        "optional": true
      },
      {
        "name": "items",
        "type": "IterableProp<I>",
        "description": "The items contained in the tree.",
        "optional": false
      },
      {
        "name": "typeaheadTimeout",
        "type": "MaybeGetter<number | undefined>",
        "description": "How many time (in ms) the typeahead string is held before it is cleared",
        "defaultValue": "500",
        "optional": true
      }
    ],
    "methods": [
      {
        "name": "isSelected",
        "type": "(id: string) => boolean",
        "description": "Checks if an item is currently selected\r@param id - ID of the item to check"
      },
      {
        "name": "isExpanded",
        "type": "(id: string) => boolean",
        "description": "Checks if an item is currently expanded\r@param id - ID of the item to check"
      },
      {
        "name": "expand",
        "type": "(id: string) => void",
        "description": "Expands a specific item\r@param id - ID of the item to expand"
      },
      {
        "name": "collapse",
        "type": "(id: string) => void",
        "description": "Collapses a specific item\r@param id - ID of the item to collapse"
      },
      {
        "name": "toggleExpand",
        "type": "(id: string) => void",
        "description": "Toggles the expanded state of an item\r@param id - ID of the item to toggle"
      },
      {
        "name": "select",
        "type": "(id: string) => void",
        "description": "Selects a specific item\r@param id - ID of the item to select"
      },
      {
        "name": "deselect",
        "type": "(id: string) => void",
        "description": "Deselects a specific item\r@param id - ID of the item to deselect"
      },
      {
        "name": "clearSelection",
        "type": "() => void",
        "description": "Clears all current selections"
      },
      {
        "name": "toggleSelect",
        "type": "(id: string) => void",
        "description": "Toggles the selected state of an item\r@param id - ID of the item to toggle"
      },
      {
        "name": "selectAll",
        "type": "() => void",
        "description": "Selects all visible items.\rIf all items are already selected, clears the selection."
      },
      {
        "name": "getItemId",
        "type": "(id: string) => string",
        "description": "Gets the DOM ID for a specific tree item\r@param id - ID of the item"
      },
      {
        "name": "getItemEl",
        "type": "(id: string) => HTMLElement | null",
        "description": "Gets the DOM element for a specific tree item\r@param id - ID of the item"
      },
      {
        "name": "selectUntil",
        "type": "(id: string) => void",
        "description": "Selects all items between the last selected item and the specified item\n@param id - ID of the item to select until"
      }
    ],
    "properties": [
      {
        "name": "collection",
        "type": "Collection<I>",
        "description": "The items contained in the tree"
      },
      {
        "name": "multiple",
        "type": "Multiple",
        "description": "If `true`, the user can select multiple items holding `Control`/`Meta` or `Shift`"
      },
      {
        "name": "expandOnClick",
        "type": "boolean",
        "description": "If `true`, groups (items with children) expand on click"
      },
      {
        "name": "typeaheadTimeout",
        "type": "number",
        "description": ""
      },
      {
        "name": "typeahead",
        "type": "(letter: string) => { child: Child<I>; value: string } | undefined",
        "description": ""
      },
      {
        "name": "items",
        "type": "I[]",
        "description": ""
      },
      {
        "name": "selected",
        "type": "FalseIfUndefined<Multiple>>",
        "description": "Currently selected item(s)\rFor multiple selection, returns a Set of IDs\rFor single selection, returns a single ID or undefined"
      },
      {
        "name": "expanded",
        "type": "SvelteSet<string>",
        "description": "Set of currently expanded item IDs"
      },
      {
        "name": "root",
        "type": "{ role: string; \"data-melt-tree-root\": string }",
        "description": "Gets ARIA attributes for the root tree element"
      },
      {
        "name": "group",
        "type": "{ role: string; \"data-melt-tree-group\": string }",
        "description": "ARIA attributes for group elements"
      },
      {
        "name": "children",
        "type": "Child<I>[]",
        "description": "Array of Child instances representing the top-level items"
      }
    ],
    "propsAlt": "\n\nexport type TreeProps<Item extends TreeItem, Multiple extends boolean = false> = {\n  /**\n   * If `true`, the user can select multiple items.\n   * @default false\n   */\n  multiple?: MaybeGetter<Multiple | undefined>;\n  /**\n   * The currently selected item(s).\n   * If `multiple` is `true`, this should be an `Iterable`.\n   * Otherwise, it'll be a `string`.\n   * @default undefined\n   */\n  selected?: MaybeMultiple<string, Multiple>;\n  /**\n   * Callback fired when selection changes\n   * @param value - For multiple selection, a Set of selected IDs. For single selection, a single ID or undefined\n   */\n  onSelectedChange?: (value: Multiple extends true ? Set<string> : string | undefined) => void;\n  /**\n   * The currently expanded items\n   *\n   * @default undefined\n   */\n  expanded?: MaybeMultiple<string, true>;\n  /**\n   * Callback fired when expanded state changes\n   * @param value - Set of expanded item IDs\n   */\n  onExpandedChange?: (value: Set<string>) => void;\n  /**\n   * If `true`, groups (items with children) expand on click.\n   * @default true\n   */\n  expandOnClick?: MaybeGetter<boolean | undefined>;\n  /**\n   * The items contained in the tree.\n   * @required\n   */\n  items: IterableProp<Item>;\n  /**\n   * How many time (in ms) the typeahead string is held before it is cleared\n   * @default 500\n   */\n  typeaheadTimeout?: MaybeGetter<number | undefined>;\n};"
  },
  "Toggle": {
    "constructorProps": [
      {
        "name": "value",
        "type": "MaybeGetter<boolean> | undefined",
        "description": "The value for the Toggle.\r\n\r\nWhen passing a getter, it will be used as source of truth,\r\nmeaning that the value only changes when the getter returns a new value.\r\n\r\nOtherwise, if passing a static value, it'll serve as the default value.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "onValueChange",
        "type": "((value: boolean) => void) | undefined",
        "description": "Called when the value is supposed to change.",
        "optional": true
      },
      {
        "name": "disabled",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If `true`, prevents the user from interacting with the input.",
        "defaultValue": "false",
        "optional": true
      }
    ],
    "methods": [],
    "properties": [
      {
        "name": "disabled",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "value",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "trigger",
        "type": "{\n  readonly \"data-melt-toggle-trigger\": \"\"\n  readonly \"data-checked\": \"\" | undefined\n  readonly \"aria-pressed\": boolean\n  readonly disabled: true | undefined\n  readonly onclick: () => void\n}",
        "description": "The trigger that toggles the value."
      },
      {
        "name": "hiddenInput",
        "type": "{\n  readonly \"data-melt-toggle-hidden-input\": \"\"\n  readonly type: \"hidden\"\n  readonly value: \"on\" | \"off\"\n}",
        "description": "A hidden input field to use within forms."
      }
    ],
    "propsAlt": "export type ToggleProps = {\r\n  /**\r\n   * The value for the Toggle.\r\n   *\r\n   * When passing a getter, it will be used as source of truth,\r\n   * meaning that the value only changes when the getter returns a new value.\r\n   *\r\n   * Otherwise, if passing a static value, it'll serve as the default value.\r\n   *\r\n   *\r\n   * @default false\r\n   */\r\n  value?: MaybeGetter<boolean>;\r\n  /**\r\n   * Called when the value is supposed to change.\r\n   */\r\n  onValueChange?: (value: boolean) => void;\r\n\r\n  /**\r\n   * If `true`, prevents the user from interacting with the input.\r\n   *\r\n   * @default false\r\n   */\r\n  disabled?: MaybeGetter<boolean | undefined>;\r\n};"
  },
  "TagsInput": {
    "constructorProps": [
      {
        "name": "tags",
        "type": "Tag[] | undefined>",
        "description": "The values for the tags.\r\n\r\nWhen passing a getter, it will be used as source of truth,\r\nmeaning that the value only changes when the getter returns a new value.\r\n\r\nOtherwise, if passing a static value, it'll serve as the default values.",
        "optional": true
      },
      {
        "name": "placeholder",
        "type": "MaybeGetter<string | undefined>",
        "description": "The placeholder text for the input element.",
        "optional": true
      },
      {
        "name": "disabled",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "Whether or not the tags input is disabled.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "editable",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "Whether or not the input is editable.",
        "defaultValue": "true",
        "optional": true
      },
      {
        "name": "selected",
        "type": "Tag | undefined>",
        "description": "The selected tag.",
        "optional": true
      },
      {
        "name": "unique",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "Whether or not the tags input should only allow unique tags.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "trim",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "Whether or not whitespace from both ends of input string should be removed when a tag is added.",
        "defaultValue": "true",
        "optional": true
      },
      {
        "name": "blur",
        "type": "MaybeGetter<Blur | undefined>",
        "description": "Define the action that should be taken when the input element loses focus (blurs).\r\n'nothing' - Left over strings in the input are left as they are.\r\n'add' - Left over strings get added as a tag.\r\n'clear' - Left over strings get cleared, so the input is empty again.",
        "defaultValue": "'nothing'",
        "optional": true
      },
      {
        "name": "addOnPaste",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "Whether or not the input should add tags on paste.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "maxTags",
        "type": "MaybeGetter<number | undefined>",
        "description": "The maximum number of tags allowed.",
        "optional": true
      },
      {
        "name": "allowed",
        "type": "MaybeGetter<string[] | undefined>",
        "description": "The allowed tags.",
        "optional": true
      },
      {
        "name": "denied",
        "type": "MaybeGetter<string[] | undefined>",
        "description": "The disallowed tags.",
        "optional": true
      },
      {
        "name": "onTagsChange",
        "type": "((value: Tag[]) => void) | undefined",
        "description": "A function that is called when the tags change.",
        "optional": true
      },
      {
        "name": "add",
        "type": "((tag: string) => string | Tag>) | undefined",
        "description": "Optional validator/parser function that runs on tag addition.\r\n\r\nIf an error is thrown, or the promise is rejected, the tag will not be added.\r\n\r\nOtherwise, return a Tag or a string for the tag to be added.",
        "optional": true
      },
      {
        "name": "remove",
        "type": "((tag: Tag) => boolean | Promise<boolean>) | undefined",
        "description": "Optional validator/parser function that runs on tag removal.\r\n\r\nIf an error is thrown, the promise is rejected, and that will not be removed.\r\nIf `false` is returned, the tag will also not be removed.\r\n\r\nOtherwise, return `true` for the tag to be removed.",
        "optional": true
      }
    ],
    "methods": [
      {
        "name": "addTag",
        "type": "(v: string) => Promise<boolean>",
        "description": "Adds a tag. Returns `true` if the tag was added.\r* @param v The string value of the tag that should be added."
      },
      {
        "name": "removeTag",
        "type": "(t: Tag) => Promise<boolean>",
        "description": "Removes the given tag. Returns `true` if successful.\r* @param t The tag to remove."
      },
      {
        "name": "updateTag",
        "type": "(id: string, newValue: string) => void",
        "description": "Update a tag.\r* @param id - The ID of the tag to update.\r@param newValue - The new value for the tag."
      },
      {
        "name": "getTagItem",
        "type": "({ tag, disabled, editable }: GetTagItemProps) => TagItem",
        "description": "A function to create a TagItem class with the necessary\rtag item element spread attributes."
      },
      {
        "name": "isInputValid",
        "type": "(v: string) => boolean",
        "description": ""
      }
    ],
    "properties": [
      {
        "name": "disabled",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "placeholder",
        "type": "string",
        "description": ""
      },
      {
        "name": "blur",
        "type": "Blur",
        "description": ""
      },
      {
        "name": "trim",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "unique",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "allowed",
        "type": "string[] | undefined",
        "description": ""
      },
      {
        "name": "denied",
        "type": "string[] | undefined",
        "description": ""
      },
      {
        "name": "maxTags",
        "type": "number | undefined",
        "description": ""
      },
      {
        "name": "editable",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "selected",
        "type": "Tag | null",
        "description": "The selected tag."
      },
      {
        "name": "editing",
        "type": "Tag | null",
        "description": "The tag being edited."
      },
      {
        "name": "isInvalidInput",
        "type": "boolean",
        "description": "Whether the entered input is valid or not."
      },
      {
        "name": "tags",
        "type": "Tag[]",
        "description": ""
      },
      {
        "name": "root",
        "type": "{\n  readonly \"data-melt-tags-input-root\": \"\"\n  readonly id: string\n  readonly \"data-invalid\": \"\" | undefined\n  readonly \"data-disabled\": true | undefined\n  readonly disabled: true | undefined\n  readonly onmousedown: (e: MouseEvent) => void\n}",
        "description": "The spread attributes for the root element."
      },
      {
        "name": "input",
        "type": "{\n  readonly \"data-melt-tags-input-input\": \"\"\n  readonly \"data-invalid\": \"\" | undefined\n  readonly id: string\n  readonly \"data-disabled\": true | undefined\n  readonly disabled: true | undefined\n  readonly placeholder: string\n  readonly onblur: FormEventHandler<HTMLInputElement>\n}",
        "description": "The spread attributes for the input element."
      }
    ],
    "propsAlt": "export type TagsInputProps = {\r\n  /**\r\n   * The values for the tags.\r\n   *\r\n   * When passing a getter, it will be used as source of truth,\r\n   * meaning that the value only changes when the getter returns a new value.\r\n   *\r\n   * Otherwise, if passing a static value, it'll serve as the default values.\r\n   */\r\n  tags?: MaybeGetter<Tag[] | undefined>;\r\n\r\n  /**\r\n   * The placeholder text for the input element.\r\n   */\r\n  placeholder?: MaybeGetter<string | undefined>;\r\n\r\n  /**\r\n   * Whether or not the tags input is disabled.\r\n   * @default false\r\n   */\r\n  disabled?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * Whether or not the input is editable.\r\n   * @default true\r\n   */\r\n  editable?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * The selected tag.\r\n   */\r\n  selected?: MaybeGetter<Tag | undefined>;\r\n\r\n  /**\r\n   * Whether or not the tags input should only allow unique tags.\r\n   * @default false\r\n   */\r\n  unique?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * Whether or not whitespace from both ends of input string should be removed when a tag is added.\r\n   * @default true\r\n   */\r\n  trim?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * Define the action that should be taken when the input element loses focus (blurs).\r\n   * 'nothing' - Left over strings in the input are left as they are.\r\n   * 'add' - Left over strings get added as a tag.\r\n   * 'clear' - Left over strings get cleared, so the input is empty again.\r\n   * @default 'nothing'\r\n   */\r\n  blur?: MaybeGetter<Blur | undefined>;\r\n\r\n  /**\r\n   * Whether or not the input should add tags on paste.\r\n   * @default false\r\n   */\r\n  addOnPaste?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * The maximum number of tags allowed.\r\n   */\r\n  maxTags?: MaybeGetter<number | undefined>;\r\n\r\n  /**\r\n   * The allowed tags.\r\n   */\r\n  allowed?: MaybeGetter<string[] | undefined>;\r\n\r\n  /**\r\n   * The disallowed tags.\r\n   */\r\n  denied?: MaybeGetter<string[] | undefined>;\r\n\r\n  /**\r\n   * A function that is called when the tags change.\r\n   */\r\n  onTagsChange?: (value: Tag[]) => void;\r\n\r\n  /**\r\n   * Optional validator/parser function that runs on tag addition.\r\n   *\r\n   * If an error is thrown, or the promise is rejected, the tag will not be added.\r\n   *\r\n   * Otherwise, return a Tag or a string for the tag to be added.\r\n   *\r\n   * @param tag The tag to be added\r\n   */\r\n  add?: (tag: string) => (Tag | string | never) | Promise<Tag | string | never>;\r\n\r\n  /**\r\n   * Optional validator/parser function that runs on tag removal.\r\n   *\r\n   * If an error is thrown, the promise is rejected, and that will not be removed.\r\n   * If `false` is returned, the tag will also not be removed.\r\n   *\r\n   * Otherwise, return `true` for the tag to be removed.\r\n   *\r\n   * @param tag The tag to be removed\r\n   */\r\n  remove?: (tag: Tag) => (boolean | never) | Promise<boolean | never>;\r\n};"
  },
  "Tabs": {
    "constructorProps": [
      {
        "name": "selectWhenFocused",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If `true`, the value will be changed whenever a trigger is focused.",
        "defaultValue": "true",
        "optional": true
      },
      {
        "name": "loop",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the the trigger selection should loop when navigating with the arrow keys.",
        "defaultValue": "true",
        "optional": true
      },
      {
        "name": "orientation",
        "type": "MaybeGetter<\"horizontal\" | \"vertical\" | undefined>",
        "description": "The orientation of the tabs.",
        "defaultValue": "\"horizontal\"",
        "optional": true
      },
      {
        "name": "value",
        "type": "MaybeGetter<T | undefined>",
        "description": "The default value for `tabs.value`\r\n\r\nWhen passing a getter, it will be used as source of truth,\r\nmeaning that `tabs.value` only changes when the getter returns a new value.\r\n\r\nIf omitted, it will use the first tab as default.",
        "defaultValue": "undefined",
        "optional": true
      },
      {
        "name": "onValueChange",
        "type": "((active: T) => void) | undefined",
        "description": "Called when the `Tabs` instance tries to change the active tab.",
        "optional": true
      }
    ],
    "methods": [
      {
        "name": "getTrigger",
        "type": "(value: T) => {\n  readonly \"data-melt-tabs-trigger\": T\n  readonly \"data-active\": \"\" | undefined\n  readonly tabindex: 0 | -1\n  readonly role: \"tab\"\n  readonly \"aria-selected\": boolean\n  readonly \"aria-controls\": string\n  readonly \"data-orientation\": \"horizontal\" | \"vertical\"\n  readonly onclick: () => T\n  readonly onkeydown: (e: KeyboardEvent) => void\n  readonly id: string\n}",
        "description": "Gets the attributes and listeners for a tab trigger. Requires an identifying tab value."
      },
      {
        "name": "getContent",
        "type": "(value: T) => {\n  readonly \"data-melt-tabs-content\": \"\"\n  readonly hidden: boolean\n  readonly \"data-active\": \"\" | undefined\n  readonly role: \"tabpanel\"\n  readonly id: string\n  readonly \"aria-labelledby\": string\n  readonly \"data-orientation\": \"horizontal\" | \"vertical\"\n}",
        "description": "Gets the attributes and listeners for the tabs contents. Requires an identifying tab value."
      }
    ],
    "properties": [
      {
        "name": "selectWhenFocused",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "loop",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "orientation",
        "type": "\"horizontal\" | \"vertical\"",
        "description": ""
      },
      {
        "name": "value",
        "type": "T",
        "description": "The current selected tab."
      },
      {
        "name": "triggerList",
        "type": "{\n  readonly \"data-melt-tabs-trigger-list\": \"\"\n  readonly role: \"tablist\"\n  readonly \"aria-orientation\": \"horizontal\" | \"vertical\"\n  readonly \"data-orientation\": \"horizontal\" | \"vertical\"\n}",
        "description": "The attributes for the list that contains the tab triggers."
      }
    ],
    "propsAlt": "export type TabsProps<T extends string = string> = {\r\n  /**\r\n   * If `true`, the value will be changed whenever a trigger is focused.\r\n   *\r\n   * @default true\r\n   */\r\n  selectWhenFocused?: MaybeGetter<boolean | undefined>;\r\n  /**\r\n   * If the the trigger selection should loop when navigating with the arrow keys.\r\n   *\r\n   * @default true\r\n   */\r\n  loop?: MaybeGetter<boolean | undefined>;\r\n  /**\r\n   * The orientation of the tabs.\r\n   *\r\n   * @default \"horizontal\"\r\n   */\r\n  orientation?: MaybeGetter<\"horizontal\" | \"vertical\" | undefined>;\r\n  /**\r\n   * The default value for `tabs.value`\r\n   *\r\n   * When passing a getter, it will be used as source of truth,\r\n   * meaning that `tabs.value` only changes when the getter returns a new value.\r\n   *\r\n   * If omitted, it will use the first tab as default.\r\n   *\r\n   * @default undefined\r\n   */\r\n  value?: MaybeGetter<T | undefined>;\r\n  /**\r\n   * Called when the `Tabs` instance tries to change the active tab.\r\n   */\r\n  onValueChange?: (active: T) => void;\r\n};"
  },
  "Slider": {
    "constructorProps": [
      {
        "name": "min",
        "type": "MaybeGetter<number | undefined>",
        "description": "The minimum value of the slider.",
        "defaultValue": "0",
        "optional": true
      },
      {
        "name": "max",
        "type": "MaybeGetter<number | undefined>",
        "description": "The maximum value of the slider.",
        "defaultValue": "100",
        "optional": true
      },
      {
        "name": "orientation",
        "type": "MaybeGetter<\"horizontal\" | \"vertical\" | undefined>",
        "description": "The orientation of the slider.",
        "defaultValue": "\"horizontal\"",
        "optional": true
      },
      {
        "name": "step",
        "type": "MaybeGetter<number | undefined>",
        "description": "The step size of the slider.",
        "defaultValue": "1",
        "optional": true
      },
      {
        "name": "value",
        "type": "MaybeGetter<number | undefined>",
        "description": "The default value for `tabs.value`\r\n\r\nWhen passing a getter, it will be used as source of truth,\r\nmeaning that `tabs.value` only changes when the getter returns a new value.\r\n\r\nIf omitted, it will use the first tab as default.",
        "defaultValue": "undefined",
        "optional": true
      },
      {
        "name": "onValueChange",
        "type": "((active: number) => void) | undefined",
        "description": "Called when the `Slider` instance tries to change the active tab.",
        "optional": true
      }
    ],
    "methods": [],
    "properties": [
      {
        "name": "min",
        "type": "number",
        "description": ""
      },
      {
        "name": "max",
        "type": "number",
        "description": ""
      },
      {
        "name": "orientation",
        "type": "\"horizontal\" | \"vertical\"",
        "description": ""
      },
      {
        "name": "step",
        "type": "number",
        "description": ""
      },
      {
        "name": "value",
        "type": "number",
        "description": "The value of the slider."
      },
      {
        "name": "root",
        "type": "{\n  readonly \"data-dragging\": \"\" | undefined\n  readonly \"data-value\": number\n  readonly \"data-orientation\": \"horizontal\" | \"vertical\"\n  readonly \"aria-valuenow\": number\n  readonly \"aria-valuemin\": number\n  readonly \"aria-valuemax\": number\n  readonly \"aria-orientation\": \"horizontal\" | \"vertical\"\n  readonly style: `--percentage: ${string}; --percentage-inv: ${string}; touch-action: ${string}`\n  readonly tabindex: 0\n  readonly role: \"slider\"\n  readonly \"data-melt-slider-root\": \"\"\n  readonly id: string\n  readonly onpointerdown: (e: PointerEvent) => void\n  readonly onkeydown: (e: KeyboardEvent) => void\n}",
        "description": "The root of the slider.\rAny cursor interaction along this element will change the slider's values."
      },
      {
        "name": "thumb",
        "type": "{\n  readonly \"data-dragging\": \"\" | undefined\n  readonly \"data-value\": number\n  readonly \"data-orientation\": \"horizontal\" | \"vertical\"\n  readonly \"data-melt-slider-thumb\": \"\"\n  readonly tabindex: 0\n}",
        "description": "The slider's thumb, positioned at the end of the range."
      }
    ],
    "propsAlt": "export type SliderProps = {\r\n  /**\r\n   * The minimum value of the slider.\r\n   *\r\n   * @default 0\r\n   */\r\n  min?: MaybeGetter<number | undefined>;\r\n  /**\r\n   * The maximum value of the slider.\r\n   *\r\n   * @default 100\r\n   */\r\n  max?: MaybeGetter<number | undefined>;\r\n  /**\r\n   * The orientation of the slider.\r\n   *\r\n   * @default \"horizontal\"\r\n   */\r\n  orientation?: MaybeGetter<\"horizontal\" | \"vertical\" | undefined>;\r\n\r\n  /**\r\n   * The step size of the slider.\r\n   *\r\n   * @default 1\r\n   */\r\n  step?: MaybeGetter<number | undefined>;\r\n  /**\r\n   * The default value for `tabs.value`\r\n   *\r\n   * When passing a getter, it will be used as source of truth,\r\n   * meaning that `tabs.value` only changes when the getter returns a new value.\r\n   *\r\n   * If omitted, it will use the first tab as default.\r\n   *\r\n   * @default undefined\r\n   */\r\n  value?: MaybeGetter<number | undefined>;\r\n  /**\r\n   * Called when the `Slider` instance tries to change the active tab.\r\n   */\r\n  onValueChange?: (active: number) => void;\r\n};"
  },
  "Select": {
    "constructorProps": [
      {
        "name": "open",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the Popover is open.\n\nWhen passing a getter, it will be used as source of truth,\nmeaning that the value only changes when the getter returns a new value.\n\nOtherwise, if passing a static value, it'll serve as the default value.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "onOpenChange",
        "type": "((value: boolean) => void) | undefined",
        "description": "Called when the value is supposed to change.",
        "optional": true
      },
      {
        "name": "forceVisible",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the popover visibility should be controlled by the user.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "computePositionOptions",
        "type": "Elements; }) => Promisable<Platform | undefined; }> | undefined>",
        "description": "Options to be passed to Floating UI's `computePosition`",
        "optional": true
      },
      {
        "name": "sameWidth",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the popover should have the same width as the trigger",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "multiple",
        "type": "MaybeGetter<Multiple | undefined>",
        "description": "If `true`, multiple options can be selected at the same time.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "value",
        "type": "MaybeMultiple<T, Multiple> | undefined",
        "description": "The value for the Select.\r\n\r\nWhen passing a getter, it will be used as source of truth,\r\nmeaning that the value only changes when the getter returns a new value.\r\n\r\nOtherwise, if passing a static value, it'll serve as the default value.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "onValueChange",
        "type": "OnMultipleChange<T, Multiple> | undefined",
        "description": "Called when the value is supposed to change.",
        "optional": true
      },
      {
        "name": "typeaheadTimeout",
        "type": "MaybeGetter<number | undefined>",
        "description": "How many time (in ms) the typeahead string is held before it is cleared",
        "defaultValue": "500",
        "optional": true
      }
    ],
    "methods": [
      {
        "name": "getOptionId",
        "type": "(value: T) => string",
        "description": ""
      },
      {
        "name": "getOption",
        "type": "(value: T) => {\n  readonly \"data-melt-select-option\": \"\"\n  readonly \"data-value\": DataReturn<T>\n  readonly \"aria-hidden\": true | undefined\n  readonly \"aria-selected\": boolean\n  readonly \"data-highlighted\": boolean\n  readonly role: \"option\"\n  readonly onmouseover: () => void\n  readonly onclick: () => void\n}",
        "description": ""
      }
    ],
    "properties": [
      {
        "name": "multiple",
        "type": "Multiple extends null | undefined\n  ? Multiple | undefined\n  : Multiple | Exclude<Multiple, null | undefined>",
        "description": ""
      },
      {
        "name": "highlighted",
        "type": "T | null",
        "description": ""
      },
      {
        "name": "typeaheadTimeout",
        "type": "number",
        "description": ""
      },
      {
        "name": "typeahead",
        "type": "(letter: string) => { value: T; current: boolean } | undefined",
        "description": ""
      },
      {
        "name": "value",
        "type": "SelectionStateValue<T, Multiple>",
        "description": ""
      },
      {
        "name": "trigger",
        "type": "{\n  readonly onfocusout: () => Promise<void>\n  readonly \"data-melt-popover-trigger\": \"\"\n  readonly id: string\n  readonly popovertarget: string\n  readonly onclick: (e: Event) => void\n} & {\n  \"data-melt-select-trigger\": string\n  role: string\n  \"aria-expanded\": boolean\n  \"aria-controls\": string\n  \"aria-owns\": string\n  onkeydown: (e: KeyboardEvent) => void\n}",
        "description": ""
      },
      {
        "name": "content",
        "type": "{\n  readonly onfocusout: () => Promise<void>\n  readonly \"data-melt-popover-content\": \"\"\n  readonly id: string\n  readonly popover: \"manual\"\n  readonly ontoggle: (\n    e: ToggleEvent & { currentTarget: EventTarget & HTMLElement },\n  ) => void\n  readonly tabindex: -1\n  readonly inert: boolean\n  readonly \"data-open\": \"\" | undefined\n} & {\n  readonly \"data-melt-select-content\": \"\"\n  readonly role: \"listbox\"\n  readonly \"aria-expanded\": boolean\n  readonly \"aria-activedescendant\": string | undefined\n  readonly onkeydown: (e: KeyboardEvent) => void\n}",
        "description": ""
      }
    ],
    "propsAlt": "export type SelectProps<T extends string, Multiple extends boolean = false> = PopoverProps & {\n  /**\n   * If `true`, multiple options can be selected at the same time.\n   *\n   * @default false\n   */\n  multiple?: MaybeGetter<Multiple | undefined>;\n\n  /**\n   * The value for the Select.\n   *\n   * When passing a getter, it will be used as source of truth,\n   * meaning that the value only changes when the getter returns a new value.\n   *\n   * Otherwise, if passing a static value, it'll serve as the default value.\n   *\n   *\n   * @default false\n   */\n  value?: MaybeMultiple<T, Multiple>;\n  /**\n   * Called when the value is supposed to change.\n   */\n  onValueChange?: OnMultipleChange<T, Multiple>;\n\n  /**\n   * How many time (in ms) the typeahead string is held before it is cleared\n   * @default 500\n   */\n  typeaheadTimeout?: MaybeGetter<number | undefined>;\n};"
  },
  "RadioGroup": {
    "constructorProps": [
      {
        "name": "disabled",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If `true`, prevents the user from interacting with the group.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "required",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If `true`, indicates that the user must select a radio button before\r\nthe owning form can be submitted.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "loop",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the the button selection should loop when navigating with the arrow keys.",
        "defaultValue": "true",
        "optional": true
      },
      {
        "name": "selectWhenFocused",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If `true`, the value will be changed whenever a button is focused.",
        "defaultValue": "true",
        "optional": true
      },
      {
        "name": "orientation",
        "type": "MaybeGetter<\"horizontal\" | \"vertical\" | undefined>",
        "description": "The orientation of the slider.",
        "defaultValue": "\"vertical\"",
        "optional": true
      },
      {
        "name": "name",
        "type": "MaybeGetter<string | undefined>",
        "description": "Input name for radio group.",
        "optional": true
      },
      {
        "name": "value",
        "type": "MaybeGetter<string | undefined>",
        "description": "Default value for radio group.",
        "defaultValue": "\"\"",
        "optional": true
      },
      {
        "name": "onValueChange",
        "type": "((active: string) => void) | undefined",
        "description": "Called when the radio button is clicked.",
        "optional": true
      }
    ],
    "methods": [
      {
        "name": "getItem",
        "type": "(item: string) => RadioItem",
        "description": ""
      },
      {
        "name": "select",
        "type": "(item: string) => void",
        "description": ""
      }
    ],
    "properties": [
      {
        "name": "disabled",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "required",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "loop",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "selectWhenFocused",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "orientation",
        "type": "\"horizontal\" | \"vertical\"",
        "description": ""
      },
      {
        "name": "value",
        "type": "string",
        "description": ""
      },
      {
        "name": "root",
        "type": "{\n  readonly \"data-melt-radio-group-root\": \"\"\n  readonly id: string\n  readonly role: \"radiogroup\"\n  readonly \"aria-required\": boolean\n  readonly \"aria-labelledby\": string\n  readonly \"data-orientation\": \"horizontal\" | \"vertical\"\n  readonly \"data-disabled\": true | undefined\n  readonly \"data-value\": string\n}",
        "description": ""
      },
      {
        "name": "label",
        "type": "{\n  readonly \"data-melt-radio-group-label\": \"\"\n  readonly id: string\n  readonly for: string\n  readonly onclick: (\n    e: MouseEvent & { currentTarget: EventTarget & HTMLLabelElement },\n  ) => void\n  readonly \"data-orientation\": \"horizontal\" | \"vertical\"\n  readonly \"data-disabled\": true | undefined\n  readonly \"data-value\": string\n}",
        "description": ""
      },
      {
        "name": "hiddenInput",
        "type": "{\n  readonly \"data-melt-radio-group-hidden-input\": \"\"\n  readonly disabled: boolean\n  readonly required: boolean\n  readonly hidden: true\n  readonly \"aria-hidden\": true\n  readonly tabindex: -1\n  readonly value: string\n  readonly name: string | undefined\n}",
        "description": ""
      }
    ],
    "propsAlt": "export type RadioGroupProps = {\r\n  /**\r\n   * If `true`, prevents the user from interacting with the group.\r\n   *\r\n   * @default false\r\n   */\r\n  disabled?: MaybeGetter<boolean | undefined>;\r\n  /**\r\n   * If `true`, indicates that the user must select a radio button before\r\n   * the owning form can be submitted.\r\n   *\r\n   * @default false\r\n   */\r\n  required?: MaybeGetter<boolean | undefined>;\r\n  /**\r\n   * If the the button selection should loop when navigating with the arrow keys.\r\n   *\r\n   * @default true\r\n   */\r\n  loop?: MaybeGetter<boolean | undefined>;\r\n  /**\r\n   * If `true`, the value will be changed whenever a button is focused.\r\n   *\r\n   * @default true\r\n   */\r\n  selectWhenFocused?: MaybeGetter<boolean | undefined>;\r\n  /**\r\n   * The orientation of the slider.\r\n   *\r\n   * @default \"vertical\"\r\n   */\r\n  orientation?: MaybeGetter<\"horizontal\" | \"vertical\" | undefined>;\r\n  /**\r\n   * Input name for radio group.\r\n   */\r\n  name?: MaybeGetter<string | undefined>;\r\n  /**\r\n   * Default value for radio group.\r\n   *\r\n   * @default \"\"\r\n   */\r\n  value?: MaybeGetter<string | undefined>;\r\n  /**\r\n   * Called when the radio button is clicked.\r\n   */\r\n  onValueChange?: (active: string) => void;\r\n};"
  },
  "Progress": {
    "constructorProps": [
      {
        "name": "value",
        "type": "MaybeGetter<number | undefined>",
        "description": "The value for the progress.",
        "defaultValue": "undefined",
        "optional": true
      },
      {
        "name": "max",
        "type": "MaybeGetter<number | undefined>",
        "description": "The maximum value of the progress.",
        "optional": true
      },
      {
        "name": "onValueChange",
        "type": "((value: number) => void) | undefined",
        "description": "The callback invoked when the value of the progress changes.",
        "optional": true
      }
    ],
    "methods": [],
    "properties": [
      {
        "name": "max",
        "type": "number",
        "description": ""
      },
      {
        "name": "value",
        "type": "number",
        "description": ""
      },
      {
        "name": "root",
        "type": "{\n  \"data-melt-progress-root\": string\n  value: number\n  max: number\n  role: string\n  \"aria-valuemin\": number\n  \"aria-valuemax\": number\n  \"aria-valuenow\": number\n  \"data-value\": number\n  \"data-state\": string\n  \"data-max\": number\n}",
        "description": "Spread attributes for the Progress root element."
      },
      {
        "name": "progress",
        "type": "{\n  \"data-melt-progress-progress\": string\n  style: `--progress: ${string}`\n}",
        "description": "Spread attributes for the Progress percentage element.\rProvides a --progress CSS variable that can be used to style the progress:\r`transform: translateX(calc(var(--progress) * -1));`"
      }
    ],
    "propsAlt": "export type ProgressProps = {\r\n  /**\r\n   * The value for the progress.\r\n   * \r\n   * @default undefined\r\n   */\r\n  value?: MaybeGetter<number | undefined>;\r\n\r\n  /**\r\n   * The maximum value of the progress.\r\n   * \r\n   * @deafult 100\r\n   */\r\n  max?: MaybeGetter<number | undefined>;\r\n\r\n  /**\r\n   * The callback invoked when the value of the progress changes.\r\n   */\r\n  onValueChange?: (value: number) => void;\r\n};"
  },
  "Popover": {
    "constructorProps": [
      {
        "name": "open",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the Popover is open.\n\nWhen passing a getter, it will be used as source of truth,\nmeaning that the value only changes when the getter returns a new value.\n\nOtherwise, if passing a static value, it'll serve as the default value.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "onOpenChange",
        "type": "((value: boolean) => void) | undefined",
        "description": "Called when the value is supposed to change.",
        "optional": true
      },
      {
        "name": "forceVisible",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the popover visibility should be controlled by the user.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "computePositionOptions",
        "type": "Elements; }) => Promisable<Platform | undefined; }> | undefined>",
        "description": "Options to be passed to Floating UI's `computePosition`",
        "optional": true
      },
      {
        "name": "sameWidth",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the popover should have the same width as the trigger",
        "defaultValue": "false",
        "optional": true
      }
    ],
    "methods": [],
    "properties": [
      {
        "name": "ids",
        "type": "Ids<DataIds<\"popover\", [\"trigger\", \"content\"]>>",
        "description": ""
      },
      {
        "name": "forceVisible",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "computePositionOptions",
        "type": "{} | Partial<{ placement?: Elements; }) => Promisable<Platform | undefined; }>",
        "description": ""
      },
      {
        "name": "open",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "trigger",
        "type": "{\n  readonly onfocusout: () => Promise<void>\n  readonly \"data-melt-popover-trigger\": \"\"\n  readonly id: string\n  readonly popovertarget: string\n  readonly onclick: (e: Event) => void\n}",
        "description": "The trigger that toggles the value."
      },
      {
        "name": "content",
        "type": "{\n  readonly onfocusout: () => Promise<void>\n  readonly \"data-melt-popover-content\": \"\"\n  readonly id: string\n  readonly popover: \"manual\"\n  readonly ontoggle: (\n    e: ToggleEvent & { currentTarget: EventTarget & HTMLElement },\n  ) => void\n  readonly tabindex: -1\n  readonly inert: boolean\n  readonly \"data-open\": \"\" | undefined\n}",
        "description": ""
      }
    ],
    "propsAlt": "export type PopoverProps = {\n  /**\n   * If the Popover is open.\n   *\n   * When passing a getter, it will be used as source of truth,\n   * meaning that the value only changes when the getter returns a new value.\n   *\n   * Otherwise, if passing a static value, it'll serve as the default value.\n   *\n   *\n   * @default false\n   */\n  open?: MaybeGetter<boolean | undefined>;\n\n  /**\n   * Called when the value is supposed to change.\n   */\n  onOpenChange?: (value: boolean) => void;\n\n  /**\n   * If the popover visibility should be controlled by the user.\n   *\n   * @default false\n   */\n  forceVisible?: MaybeGetter<boolean | undefined>;\n\n  /**\n   * Options to be passed to Floating UI's `computePosition`\n   *\n   * @see https://floating-ui.com/docs/computePosition\n   */\n  computePositionOptions?: MaybeGetter<Partial<ComputePositionConfig> | undefined>;\n\n  /**\n   * If the popover should have the same width as the trigger\n   *\n   * @default false\n   */\n  sameWidth?: MaybeGetter<boolean | undefined>;\n};"
  },
  "PinInput": {
    "constructorProps": [
      {
        "name": "value",
        "type": "MaybeGetter<string | undefined>",
        "description": "The value for the Pin Input.\r\n\r\nWhen passing a getter, it will be used as source of truth,\r\nmeaning that the value only changes when the getter returns a new value.\r\n\r\nOtherwise, if passing a static value, it'll serve as the default value.",
        "defaultValue": "''",
        "optional": true
      },
      {
        "name": "onValueChange",
        "type": "((value: string) => void) | undefined",
        "description": "Called when the `PinInput` instance tries to change the value.",
        "optional": true
      },
      {
        "name": "onComplete",
        "type": "((value: string) => void) | undefined",
        "description": "Calledwhen the `PinInput` instance is filled.",
        "optional": true
      },
      {
        "name": "maxLength",
        "type": "MaybeGetter<number | undefined>",
        "description": "The amount of digits in the Pin Input.",
        "defaultValue": "4",
        "optional": true
      },
      {
        "name": "placeholder",
        "type": "MaybeGetter<string | undefined>",
        "description": "An optional placeholder to display when the input is empty.",
        "defaultValue": "'â—‹'",
        "optional": true
      },
      {
        "name": "disabled",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If `true`, prevents the user from interacting with the input.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "mask",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If the input should be masked like a password.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "type",
        "type": "MaybeGetter<\"alphanumeric\" | \"numeric\" | \"text\" | undefined>",
        "description": "What characters the input accepts.",
        "defaultValue": "'text'",
        "optional": true
      },
      {
        "name": "allowPaste",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "If `true`, allows pasting values from the clipboard.",
        "defaultValue": "true",
        "optional": true
      }
    ],
    "methods": [],
    "properties": [
      {
        "name": "maxLength",
        "type": "number",
        "description": ""
      },
      {
        "name": "placeholder",
        "type": "string",
        "description": ""
      },
      {
        "name": "disabled",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "mask",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "type",
        "type": "\"alphanumeric\" | \"numeric\" | \"text\"",
        "description": ""
      },
      {
        "name": "allowPaste",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "isFilled",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "value",
        "type": "string",
        "description": ""
      },
      {
        "name": "root",
        "type": "{\n  readonly \"data-melt-pin-input-root\": \"\"\n  readonly id: string\n  readonly \"data-complete\": \"\" | undefined\n}",
        "description": "The root element's props."
      },
      {
        "name": "inputs",
        "type": "{\n  readonly \"data-melt-pin-input-input\": \"\"\n  readonly placeholder: string | undefined\n  readonly disabled: true | undefined\n  readonly type: \"text\" | \"password\"\n  readonly \"data-filled\": \"\" | undefined\n  readonly tabindex: 0 | -1\n  readonly inputmode: \"numeric\" | \"text\"\n  readonly style: \"caret-color: transparent;\" | undefined\n  readonly onkeydown: (e: KeyboardEvent) => void\n  readonly onpointerdown: (e: Event) => void\n  readonly onpointerup: (e: Event) => void\n  readonly oninput: (e: Event) => void\n  readonly onfocus: () => void\n  readonly onblur: () => void\n  readonly onpaste: (\n    e: ClipboardEvent & { currentTarget: EventTarget & HTMLInputElement },\n  ) => void\n}[]",
        "description": "An array of props that should be spread to the input elements."
      }
    ],
    "propsAlt": "export type PinInputProps = {\r\n  /**\r\n   * The value for the Pin Input.\r\n   *\r\n   * When passing a getter, it will be used as source of truth,\r\n   * meaning that the value only changes when the getter returns a new value.\r\n   *\r\n   * Otherwise, if passing a static value, it'll serve as the default value.\r\n   *\r\n   *\r\n   * @default ''\r\n   */\r\n  value?: MaybeGetter<string | undefined>;\r\n  /**\r\n   * Called when the `PinInput` instance tries to change the value.\r\n   */\r\n  onValueChange?: (value: string) => void;\r\n\r\n  /**\r\n   * Calledwhen the `PinInput` instance is filled.\r\n   */\r\n  onComplete?: (value: string) => void;\r\n\r\n  /**\r\n   * The amount of digits in the Pin Input.\r\n   *\r\n   * @default 4\r\n   */\r\n  maxLength?: MaybeGetter<number | undefined>;\r\n  /**\r\n   * An optional placeholder to display when the input is empty.\r\n   *\r\n   * @default 'â—‹'\r\n   */\r\n  placeholder?: MaybeGetter<string | undefined>;\r\n\r\n  /**\r\n   * If `true`, prevents the user from interacting with the input.\r\n   *\r\n   * @default false\r\n   */\r\n  disabled?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * If the input should be masked like a password.\r\n   *\r\n   * @default false\r\n   */\r\n  mask?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * What characters the input accepts.\r\n   *\r\n   * @default 'text'\r\n   */\r\n  type?: MaybeGetter<\"alphanumeric\" | \"numeric\" | \"text\" | undefined>;\r\n\r\n  /**\r\n   * If `true`, allows pasting values from the clipboard.\r\n   *\r\n   * @default true\r\n   */\r\n  allowPaste?: MaybeGetter<boolean | undefined>;\r\n};"
  },
  "FileUpload": {
    "constructorProps": [
      {
        "name": "selected",
        "type": "MaybeMultiple<File, Multiple> | undefined",
        "description": "The currently selected files.",
        "optional": true
      },
      {
        "name": "onSelectedChange",
        "type": "| ((files: Multiple extends true ? Set<File> : File | undefined) => void)\n  | undefined",
        "description": "Callback fired when selected files change",
        "optional": true
      },
      {
        "name": "multiple",
        "type": "MaybeGetter<Multiple | undefined>",
        "description": "Whether to accept multiple files",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "accept",
        "type": "MaybeGetter<string | undefined>",
        "description": "The accepted file types. Can be a MIME type, a MIME group, or a file extension.\r\nSeparate multiple types with a comma.",
        "optional": true
      },
      {
        "name": "maxSize",
        "type": "MaybeGetter<number | undefined>",
        "description": "Maximum file size in bytes",
        "defaultValue": "undefined",
        "optional": true
      },
      {
        "name": "validate",
        "type": "((file: File) => boolean) | undefined",
        "description": "Custom validate fn. Will be called together with the original validation,\r\nwhich takes into account the `accept` and `maxSize` props.",
        "optional": true
      },
      {
        "name": "onError",
        "type": "((error: FileUploadError) => void) | undefined",
        "description": "Callback fired when a file fails validation",
        "optional": true
      },
      {
        "name": "onAccept",
        "type": "((file: File) => void) | undefined",
        "description": "Callback fired when a file is accepted",
        "optional": true
      }
    ],
    "methods": [
      {
        "name": "clear",
        "type": "() => void",
        "description": "Clears the currently selected files"
      },
      {
        "name": "remove",
        "type": "(file: File) => void",
        "description": "Removes a file from the selection"
      }
    ],
    "properties": [
      {
        "name": "multiple",
        "type": "Multiple",
        "description": ""
      },
      {
        "name": "accept",
        "type": "string | undefined",
        "description": ""
      },
      {
        "name": "maxSize",
        "type": "number | undefined",
        "description": ""
      },
      {
        "name": "isDragging",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "selected",
        "type": "SelectionStateValue<File, Multiple>",
        "description": "Gets the currently selected files"
      },
      {
        "name": "dropzone",
        "type": "{\n  readonly \"data-melt-fileupload-dropzone\": \"\"\n  readonly \"data-dragging\": \"\" | undefined\n  readonly ondragenter: (e: DragEvent) => void\n  readonly ondragleave: (e: DragEvent) => void\n  readonly ondragover: (e: DragEvent) => void\n  readonly ondrop: (e: DragEvent) => void\n  readonly onclick: () => void\n}",
        "description": "The dropzone element, where you can drag files into, or click to open the file picker."
      },
      {
        "name": "input",
        "type": "{\n  readonly \"data-melt-fileupload-input\": \"\"\n  readonly id: string\n  readonly type: \"file\"\n  readonly accept: string | undefined\n  readonly multiple: Multiple\n  readonly style: \"display: none;\"\n  readonly onchange: (e: Event) => void\n}",
        "description": "The hidden file input element."
      },
      {
        "name": "trigger",
        "type": "{ readonly onclick: () => void }",
        "description": "An optional trigger element, which can be used to open the file picker."
      }
    ],
    "propsAlt": "export type FileUploadProps<Multiple extends boolean = false> = {\r\n  /**\r\n   * The currently selected files.\r\n   */\r\n  selected?: MaybeMultiple<File, Multiple>;\r\n\r\n  /**\r\n   * Callback fired when selected files change\r\n   */\r\n  onSelectedChange?: (files: Multiple extends true ? Set<File> : File | undefined) => void;\r\n\r\n  /**\r\n   * Whether to accept multiple files\r\n   * @default false\r\n   */\r\n  multiple?: MaybeGetter<Multiple | undefined>;\r\n\r\n  /**\r\n   * The accepted file types. Can be a MIME type, a MIME group, or a file extension.\r\n   * Separate multiple types with a comma.\r\n   * @example 'image/jpeg'\r\n   * @example 'image/*'\r\n   * @example '.png, .jpg, .jpeg'\r\n   */\r\n  accept?: MaybeGetter<string | undefined>;\r\n\r\n  /**\r\n   * Maximum file size in bytes\r\n   * @default undefined\r\n   */\r\n  maxSize?: MaybeGetter<number | undefined>;\r\n\r\n  /**\r\n   * Custom validate fn. Will be called together with the original validation,\r\n   * which takes into account the `accept` and `maxSize` props.\r\n   */\r\n  validate?: (file: File) => boolean;\r\n\r\n  /**\r\n   * Callback fired when a file fails validation\r\n   */\r\n  onError?: (error: FileUploadError) => void;\r\n\r\n  /**\r\n   * Callback fired when a file is accepted\r\n   */\r\n  onAccept?: (file: File) => void;\r\n};"
  },
  "Collapsible": {
    "constructorProps": [
      {
        "name": "disabled",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "Whether the collapsible is disabled which prevents it from being opened.",
        "optional": true
      },
      {
        "name": "open",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "Whether the collapsible is open.",
        "optional": true
      },
      {
        "name": "onOpenChange",
        "type": "((value: boolean) => void) | undefined",
        "description": "A callback called when the value of `open` changes.",
        "optional": true
      }
    ],
    "methods": [],
    "properties": [
      {
        "name": "disabled",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "open",
        "type": "boolean",
        "description": "The open state of the collapsible."
      },
      {
        "name": "trigger",
        "type": "{\n  disabled: boolean\n  onclick: () => void\n  \"data-state\": string\n  \"data-disabled\": \"\" | undefined\n  \"data-melt-collapsible-trigger\": string\n}",
        "description": "The spread attributes for the trigger button."
      },
      {
        "name": "content",
        "type": "{\n  \"data-state\": string\n  \"data-disabled\": \"\" | undefined\n  \"data-melt-collapsible-content\": string\n}",
        "description": "The spread attributes for the content element."
      }
    ],
    "propsAlt": "export type CollapsibleProps = {\r\n  /**\r\n   * Whether the collapsible is disabled which prevents it from being opened.\r\n   */\r\n  disabled?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * Whether the collapsible is open.\r\n   */\r\n  open?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * A callback called when the value of `open` changes.\r\n   */\r\n  onOpenChange?: (value: boolean) => void;\r\n};"
  },
  "Avatar": {
    "constructorProps": [
      {
        "name": "src",
        "type": "MaybeGetter<string | undefined>",
        "description": "The source of the image to display.",
        "optional": true
      },
      {
        "name": "delayMs",
        "type": "MaybeGetter<number | undefined>",
        "description": "The amount of time in milliseconds to wait before displaying the image.",
        "defaultValue": "0",
        "optional": true
      },
      {
        "name": "onLoadingStatusChange",
        "type": "((value: ImageLoadingStatus) => void | undefined) | undefined",
        "description": "A callback invoked when the loading status store of the avatar changes.",
        "optional": true
      }
    ],
    "methods": [],
    "properties": [
      {
        "name": "src",
        "type": "string",
        "description": ""
      },
      {
        "name": "delayMs",
        "type": "number",
        "description": ""
      },
      {
        "name": "loadingStatus",
        "type": "ImageLoadingStatus",
        "description": ""
      },
      {
        "name": "image",
        "type": "{\n  readonly \"data-melt-avatar-image\": \"\"\n  readonly src: string\n  readonly style: `display: ${string}`\n  readonly onload: () => (() => void) | undefined\n  readonly onerror: () => void\n}",
        "description": ""
      },
      {
        "name": "fallback",
        "type": "{\n  readonly \"data-melt-avatar-fallback\": \"\"\n  readonly style: `display: ${string}` | undefined\n  readonly hidden: true | undefined\n}",
        "description": ""
      }
    ],
    "propsAlt": "export type AvatarProps = {\r\n  /**\r\n   * The source of the image to display.\r\n   */\r\n  src?: MaybeGetter<string | undefined>;\r\n\r\n  /**\r\n   * The amount of time in milliseconds to wait before displaying the image.\r\n   *\r\n   * @default 0\r\n   */\r\n  delayMs?: MaybeGetter<number | undefined>;\r\n\r\n  /**\r\n   * A callback invoked when the loading status store of the avatar changes.\r\n   */\r\n  onLoadingStatusChange?: (value: ImageLoadingStatus) => void | undefined;\r\n};"
  },
  "Accordion": {
    "constructorProps": [
      {
        "name": "multiple",
        "type": "MaybeGetter<Multiple | undefined>",
        "description": "If `true`, multiple accordion items can be open at the same time.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "disabled",
        "type": "MaybeGetter<boolean | undefined>",
        "description": "When `true`, prevents the user from interacting with the accordion.",
        "defaultValue": "false",
        "optional": true
      },
      {
        "name": "value",
        "type": "MaybeMultiple<string, Multiple> | undefined",
        "description": "The controlled value for the accordion.",
        "optional": true
      },
      {
        "name": "onValueChange",
        "type": "OnMultipleChange<string, Multiple> | undefined",
        "description": "The callback invoked when the value of the Accordion changes.",
        "optional": true
      }
    ],
    "methods": [
      {
        "name": "getItem",
        "type": "<Meta extends Record<string, unknown>>(\n  item: AccordionItem<Meta>,\n) => Item<Meta, Multiple>",
        "description": "Returns an Item class with the necessary\rspread attributes for an accordion item.\r@param item"
      },
      {
        "name": "isExpanded",
        "type": "(id: string) => boolean",
        "description": "Checks if an item is currently expanded.\r@param id - ID of the item to check."
      },
      {
        "name": "expand",
        "type": "(id: string) => void",
        "description": "Expands a specific item.\r@param id - ID of the item to expand."
      },
      {
        "name": "collapse",
        "type": "(id: string) => void",
        "description": "Collapses a specific item.\r@param id - ID of the item to collapse."
      },
      {
        "name": "toggleExpanded",
        "type": "(id: string) => void",
        "description": "Toggles the expanded state of an item.\r@param id - ID of the item to toggle."
      }
    ],
    "properties": [
      {
        "name": "multiple",
        "type": "Multiple extends null | undefined\n  ? Multiple | undefined\n  : Multiple | Exclude<Multiple, null | undefined>",
        "description": ""
      },
      {
        "name": "disabled",
        "type": "boolean",
        "description": ""
      },
      {
        "name": "value",
        "type": "FalseIfUndefined<Multiple>>",
        "description": ""
      },
      {
        "name": "root",
        "type": "{ \"data-melt-accordion-root\": string; id: string }",
        "description": "Spread attributes for the accordion root element."
      }
    ],
    "propsAlt": "export type AccordionProps<Multiple extends boolean = false> = {\r\n  /**\r\n   * If `true`, multiple accordion items can be open at the same time.\r\n   *\r\n   * @default false\r\n   */\r\n  multiple?: MaybeGetter<Multiple | undefined>;\r\n\r\n  /**\r\n   * When `true`, prevents the user from interacting with the accordion.\r\n   *\r\n   * @default false\r\n   */\r\n  disabled?: MaybeGetter<boolean | undefined>;\r\n\r\n  /**\r\n   * The controlled value for the accordion.\r\n   */\r\n  value?: AccordionValue<Multiple>;\r\n\r\n  /**\r\n   * The callback invoked when the value of the Accordion changes.\r\n   */\r\n  onValueChange?: OnMultipleChange<string, Multiple>;\r\n};"
  }
}